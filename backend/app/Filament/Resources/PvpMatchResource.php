<?php

namespace App\Filament\Resources;

use App\Filament\Resources\PvpMatchResource\Pages;
use App\Models\PvpMatch;
use App\Models\PvpMatchEvent;
use App\Models\PvpMatchPlayer;
use Filament\Forms\Form;
use Filament\Infolists\Components\Grid;
use Filament\Infolists\Components\RepeatableEntry;
use Filament\Infolists\Components\Section;
use Filament\Infolists\Components\TextEntry;
use Filament\Infolists\Infolist;
use Filament\Resources\Resource;
use Filament\Tables;
use Filament\Tables\Table;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Arr;
use Illuminate\Support\Carbon;

/**
 * Filament resource used to inspect finished PvP matches.
 *
 * This resource is read-only on purpose: it is meant to provide full visibility
 * on past matches (participants, provenance, timeline, round recap and state)
 * without allowing any manual modification.
 */
class PvpMatchResource extends Resource
{
    protected static ?string $model = PvpMatch::class;

    protected static ?string $navigationIcon = 'heroicon-o-bolt';
    protected static ?string $navigationGroup = 'PvP';
    protected static ?string $navigationLabel = 'Matches';
    protected static ?string $pluralLabel = 'PvP matches';
    protected static ?string $modelLabel = 'PvP match';
    protected static ?int $navigationSort = 10;

    /**
     * PvP matches are generated by the game, there is nothing to edit manually.
     *
     * @param Form $form
     *
     * @return Form
     */
    public static function form(Form $form): Form
    {
        return $form->schema([]);
    }

    /**
     * Define the matches table.
     *
     * @param Table $table
     *
     * @return Table
     */
    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('id')
                    ->label('ID')
                    ->sortable(),

                Tables\Columns\TextColumn::make('game')
                    ->label('Game')
                    ->badge()
                    ->sortable()
                    ->searchable(),

                Tables\Columns\TextColumn::make('status')
                    ->label('Status')
                    ->badge()
                    ->sortable(),

                Tables\Columns\TextColumn::make('origin')
                    ->label('Origin')
                    ->badge()
                    ->getStateUsing(fn (PvpMatch $record): string => $record->lobby ? 'lobby' : 'queue')
                    ->sortable(query: function (Builder $query, string $direction): Builder {
                        $direction = strtolower($direction) === 'asc' ? 'asc' : 'desc';

                        return $query
                            ->leftJoin('pvp_lobbies', 'pvp_lobbies.match_id', '=', 'pvp_matches.id')
                            ->orderByRaw("CASE WHEN pvp_lobbies.id IS NULL THEN 'queue' ELSE 'lobby' END $direction")
                            ->select('pvp_matches.*');
                    }),

                Tables\Columns\TextColumn::make('players')
                    ->label('Players')
                    ->getStateUsing(function (PvpMatch $record): string {
                        $players = $record->players;

                        return $players
                            ->sortBy('seat')
                            ->map(fn (PvpMatchPlayer $p) => (string) ($p->user?->name ?? "#{$p->user_id}"))
                            ->implode(' vs ');
                    })
                    ->searchable(query: function (Builder $query, string $search): Builder {
                        $search = trim($search);
                        if ($search === '') {
                            return $query;
                        }

                        return $query->whereHas('players.user', function (Builder $q) use ($search): void {
                            $q->where('name', 'ILIKE', '%' . $search . '%');
                        });
                    }),

                Tables\Columns\TextColumn::make('best_of')
                    ->label('BO')
                    ->sortable(),

                Tables\Columns\TextColumn::make('winner')
                    ->label('Winner')
                    ->getStateUsing(function (PvpMatch $record): string {
                        $winnerUserId = (int) Arr::get($record->state ?? [], 'winner_user_id', 0);
                        if ($winnerUserId <= 0) {
                            return '—';
                        }

                        $winner = $record->players->firstWhere('user_id', $winnerUserId);
                        if ($winner?->user?->name) {
                            return (string) $winner->user->name;
                        }

                        return "#{$winnerUserId}";
                    }),

                Tables\Columns\TextColumn::make('started_at')
                    ->label('Started')
                    ->dateTime('Y-m-d H:i:s')
                    ->sortable(),

                Tables\Columns\TextColumn::make('finished_at')
                    ->label('Finished')
                    ->dateTime('Y-m-d H:i:s')
                    ->sortable(),
            ])
            ->filters([
                Tables\Filters\SelectFilter::make('game')
                    ->label('Game')
                    ->options([
                        'kcdle' => 'KCDLE',
                        'lfldle' => 'LFLDLE',
                        'lecdle' => 'LECDLE',
                    ]),

                Tables\Filters\SelectFilter::make('origin')
                    ->label('Origin')
                    ->options([
                        'queue' => 'Queue',
                        'lobby' => 'Lobby',
                    ])
                    ->query(function (Builder $query, array $data): Builder {
                        $value = (string) ($data['value'] ?? '');
                        if ($value === 'lobby') {
                            return $query->whereHas('lobby');
                        }
                        if ($value === 'queue') {
                            return $query->whereDoesntHave('lobby');
                        }

                        return $query;
                    }),

                Tables\Filters\SelectFilter::make('ended_reason')
                    ->label('Ended reason')
                    ->options([
                        'points' => 'Points',
                        'leave' => 'Leave',
                        'afk' => 'AFK',
                    ])
                    ->query(function (Builder $query, array $data): Builder {
                        $value = (string) ($data['value'] ?? '');
                        if ($value === '') {
                            return $query;
                        }

                        return $query->whereRaw("(state->>'ended_reason') = ?", [$value]);
                    }),
            ])
            ->defaultSort('finished_at', 'desc')
            ->actions([
                Tables\Actions\ViewAction::make(),
            ])
            ->bulkActions([]);
    }

    /**
     * Define the record infolist used by the view page.
     *
     * @param Infolist $infolist
     *
     * @return Infolist
     */
    public static function infolist(Infolist $infolist): Infolist
    {
        return $infolist
            ->schema([
                Section::make('Match')
                    ->schema([
                        Grid::make(3)
                            ->schema([
                                TextEntry::make('id')->label('ID'),
                                TextEntry::make('game')->label('Game')->badge(),
                                TextEntry::make('status')->label('Status')->badge(),

                                TextEntry::make('origin')
                                    ->label('Origin')
                                    ->badge()
                                    ->state(fn (PvpMatch $record): string => $record->lobby ? 'lobby' : 'queue'),

                                TextEntry::make('lobby.code')
                                    ->label('Lobby code')
                                    ->state(fn (PvpMatch $record): ?string => $record->lobby?->code),

                                TextEntry::make('best_of')->label('Best of'),

                                TextEntry::make('started_at')
                                    ->label('Started at')
                                    ->dateTime('Y-m-d H:i:s'),

                                TextEntry::make('finished_at')
                                    ->label('Finished at')
                                    ->dateTime('Y-m-d H:i:s'),

                                TextEntry::make('duration')
                                    ->label('Duration')
                                    ->state(fn (PvpMatch $record): string => static::formatDuration($record->started_at, $record->finished_at, $record->created_at)),

                                TextEntry::make('ended_reason')
                                    ->label('Ended reason')
                                    ->state(fn (PvpMatch $record): string => (string) Arr::get($record->state ?? [], 'ended_reason', '—')),

                                TextEntry::make('winner')
                                    ->label('Winner')
                                    ->state(fn (PvpMatch $record): string => static::winnerLabel($record)),

                                TextEntry::make('forfeiting_user')
                                    ->label('Forfeiting user')
                                    ->state(fn (PvpMatch $record): string => static::forfeitingUserLabel($record)),
                            ]),
                    ]),

                Section::make('Players')
                    ->schema([
                        RepeatableEntry::make('players')
                            ->label('')
                            ->schema([
                                Grid::make(6)
                                    ->schema([
                                        TextEntry::make('seat')->label('Seat'),
                                        TextEntry::make('user_id')->label('User ID'),
                                        TextEntry::make('user.name')->label('Name'),
                                        TextEntry::make('points')->label('Points'),
                                        TextEntry::make('last_seen_at')->label('Last seen')->dateTime('Y-m-d H:i:s'),
                                        TextEntry::make('last_action_at')->label('Last action')->dateTime('Y-m-d H:i:s'),
                                    ]),
                            ])
                            ->columns(1),
                    ]),

                Section::make('Rounds configuration')
                    ->schema([
                        TextEntry::make('rounds')
                            ->label('Rounds')
                            ->state(fn (PvpMatch $record): string => static::prettyJson($record->rounds))
                            ->extraAttributes(['class' => 'whitespace-pre-wrap font-mono text-xs'])
                            ->columnSpanFull(),
                    ]),

                Section::make('Match state')
                    ->schema([
                        TextEntry::make('state')
                            ->label('State')
                            ->state(fn (PvpMatch $record): string => static::prettyJson($record->state))
                            ->extraAttributes(['class' => 'whitespace-pre-wrap font-mono text-xs'])
                            ->columnSpanFull(),
                    ]),

                Section::make('Round history')
                    ->schema([
                        TextEntry::make('round_history')
                            ->label('Round history')
                            ->state(fn (PvpMatch $record): string => static::prettyJson(static::buildRoundHistory($record)))
                            ->extraAttributes(['class' => 'whitespace-pre-wrap font-mono text-xs'])
                            ->columnSpanFull(),
                    ]),

                Section::make('Round recaps')
                    ->schema([
                        TextEntry::make('round_recaps')
                            ->label('Round recaps')
                            ->state(fn (PvpMatch $record): string => static::prettyJson(static::buildRoundRecaps($record)))
                            ->extraAttributes(['class' => 'whitespace-pre-wrap font-mono text-xs'])
                            ->columnSpanFull(),
                    ]),

                Section::make('Event timeline')
                    ->schema([
                        RepeatableEntry::make('events')
                            ->label('')
                            ->schema([
                                Grid::make(4)
                                    ->schema([
                                        TextEntry::make('id')->label('ID'),
                                        TextEntry::make('type')->label('Type'),
                                        TextEntry::make('user_id')->label('User ID'),
                                        TextEntry::make('created_at')->label('Created at')->dateTime('Y-m-d H:i:s'),
                                    ]),
                                TextEntry::make('payload')
                                    ->label('Payload')
                                    ->state(fn (PvpMatchEvent $event): string => static::prettyJson($event->payload))
                                    ->extraAttributes(['class' => 'whitespace-pre-wrap font-mono text-xs'])
                                    ->columnSpanFull(),
                            ])
                            ->columns(1),
                    ]),
            ]);
    }

    /**
     * Restrict the listing to finished matches.
     *
     * @return Builder<PvpMatch>
     */
    public static function getEloquentQuery(): Builder
    {
        return parent::getEloquentQuery()
            ->where('status', 'finished')
            ->with([
                'players.user:id,name',
                'lobby:id,match_id,code,host_user_id,guest_user_id',
            ]);
    }

    /**
     * @return array<string, array<string, mixed>>
     */
    public static function getPages(): array
    {
        return [
            'index' => Pages\ListPvpMatches::route('/'),
            'view' => Pages\ViewPvpMatch::route('/{record}'),
        ];
    }

    /**
     * @return bool
     */
    public static function canCreate(): bool
    {
        return false;
    }

    /**
     * @param mixed $record
     *
     * @return bool
     */
    public static function canEdit($record): bool
    {
        return false;
    }

    /**
     * @param mixed $record
     *
     * @return bool
     */
    public static function canDelete($record): bool
    {
        return false;
    }

    /**
     * @param mixed $value
     *
     * @return string
     */
    private static function prettyJson($value): string
    {
        if ($value === null) {
            return '—';
        }

        $encoded = json_encode($value, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);

        return is_string($encoded) && $encoded !== '' ? $encoded : '—';
    }

    /**
     * @param Carbon|null $startedAt
     * @param Carbon|null $finishedAt
     * @param Carbon|null $createdAt
     *
     * @return string
     */
    private static function formatDuration(?Carbon $startedAt, ?Carbon $finishedAt, ?Carbon $createdAt): string
    {
        $start = $startedAt ?? $createdAt;
        $end = $finishedAt;

        if ($start === null || $end === null) {
            return '—';
        }

        $seconds = $start->diffInSeconds($end);

        $h = intdiv($seconds, 3600);
        $m = intdiv($seconds % 3600, 60);
        $s = $seconds % 60;

        if ($h > 0) {
            return sprintf('%dh %02dm %02ds', $h, $m, $s);
        }

        return sprintf('%dm %02ds', $m, $s);
    }

    /**
     * @param PvpMatch $match
     *
     * @return string
     */
    private static function winnerLabel(PvpMatch $match): string
    {
        $winnerUserId = (int) Arr::get($match->state ?? [], 'winner_user_id', 0);
        if ($winnerUserId <= 0) {
            return '—';
        }

        $winner = $match->players->firstWhere('user_id', $winnerUserId);
        if ($winner?->user?->name) {
            return (string) $winner->user->name;
        }

        return "#{$winnerUserId}";
    }

    /**
     * @param PvpMatch $match
     *
     * @return string
     */
    private static function forfeitingUserLabel(PvpMatch $match): string
    {
        $forfeitingUserId = (int) Arr::get($match->state ?? [], 'forfeiting_user_id', 0);
        if ($forfeitingUserId <= 0) {
            return '—';
        }

        $player = $match->players->firstWhere('user_id', $forfeitingUserId);
        if ($player?->user?->name) {
            return (string) $player->user->name;
        }

        return "#{$forfeitingUserId}";
    }

    /**
     * @param PvpMatch $match
     *
     * @return array<int, array{round:int, round_type:string, winner_user_id:int}>
     */
    private static function buildRoundHistory(PvpMatch $match): array
    {
        $events = $match->events
            ->where('type', 'round_finished')
            ->values();

        return $events
            ->map(function (PvpMatchEvent $e): array {
                $p = is_array($e->payload) ? $e->payload : [];

                return [
                    'round' => (int) ($p['round'] ?? 0),
                    'round_type' => (string) ($p['round_type'] ?? ''),
                    'winner_user_id' => (int) ($p['winner_user_id'] ?? 0),
                ];
            })
            ->filter(fn (array $x): bool => $x['round'] > 0 && $x['round_type'] !== '' && $x['winner_user_id'] > 0)
            ->values()
            ->all();
    }

    /**
     * @param PvpMatch $match
     *
     * @return array<int, array{round:int, round_type:string, timeline:array<int, array{id:int, type:string, created_at:string|null, payload:array|null}>}>
     */
    private static function buildRoundRecaps(PvpMatch $match): array
    {
        $history = static::buildRoundHistory($match);
        $historyByRound = [];

        foreach ($history as $h) {
            $r = (int) ($h['round'] ?? 0);
            $t = (string) ($h['round_type'] ?? '');
            if ($r > 0 && $t !== '') {
                $historyByRound[$r] = $t;
            }
        }

        $events = $match->events->sortBy('id');

        $grouped = [];
        foreach ($events as $e) {
            $p = is_array($e->payload) ? $e->payload : null;
            $round = is_array($p) ? (int) ($p['round'] ?? 0) : 0;
            if ($round <= 0) {
                continue;
            }

            $roundType = is_array($p) ? (string) ($p['round_type'] ?? '') : '';
            if ($roundType === '' && isset($historyByRound[$round])) {
                $roundType = (string) $historyByRound[$round];
            }

            if (! isset($grouped[$round])) {
                $grouped[$round] = [
                    'round' => $round,
                    'round_type' => $roundType,
                    'timeline' => [],
                ];
            }

            $grouped[$round]['timeline'][] = [
                'id' => (int) $e->id,
                'type' => (string) $e->type,
                'created_at' => $e->created_at?->toISOString(),
                'payload' => $p,
            ];
        }

        ksort($grouped);

        return array_values($grouped);
    }
}
